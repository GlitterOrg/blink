<!--
Copyright 2014 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
-->

<!doctype html>
<head>
<title>Benchmark - Balls Animation using Web Animations Element.animate</title>
<style>
html {
    height: 100%;
}

body {
    width: 100%;
    height: 100%;
    overflow: hidden;
    margin: 0;
    padding: 0;
}

span {
    position: absolute;
    width: 12px;
    height: 12px;
    border-radius: 6px;
}
</style>
<script src="../resources/runner.js"></script>
<script src="resources/framerate.js"></script>
<script>
var stageWidth = 600;
var stageHeight = 600;
var maxParticles = 2500;
var minVelocity = 50;
var maxVelocity = 500;
var particleRadius = 6;
var colors = ["#cc0000", "#ffcc00", "#aaff00", "#0099cc", "#194c99", "#661999"];
var animationDuration = 10;

var particles = [];
var allParticleKeyframes = [];

window.onload = function () {
    PerfTestRunner.prepareToMeasureValuesAsync({done: onCompletedRun, unit: 'fps'});

    // Create the particles
    for (var i = 0; i < maxParticles; i++) {
        generateParticleKeyframes(i);
        var particle = new Particle(i);
        particles.push(particle);
    }
    for (var i = 0; i < maxParticles; i++)
        particles[i].start();

    startTrackingFrameRate();
}

function generateParticleKeyframes(index) {
    allParticleKeyframes[index] = [];

    var angle = Math.PI * 2 * PerfTestRunner.random();
    var velocity = minVelocity + ((maxVelocity - minVelocity) * PerfTestRunner.random());
    var x = stageWidth / 2 - particleRadius;
    var y = stageHeight / 2 - particleRadius;
    var dx = Math.cos(angle) * velocity;
    var dy = Math.sin(angle) * velocity;

    function detectCollision(lineX, normalX, lineY, normalY) {
        var dtx = Infinity;
        var dty = Infinity;
        if (dx * normalX < 0)
            dtx = (lineX - x) / dx;
        if (dy * normalY < 0)
            dty = (lineY - y) / dy;
        var dt = Math.min(dtx, dty);
        var hitX = (dtx < dty);
        return {
            dt: dt,
            x: hitX ? lineX : x + (dx * dt),
            y: hitX ? y + (dy * dt) : lineY,
            dx: hitX ? -dx : dx,
            dy: hitX ? dy : -dy,
        };
    }

    var t = 0;
    allParticleKeyframes[index].push(generateKeyframe(0, x, y));
    while (t < animationDuration) {
        var collisionA = detectCollision(0, 1, 0, 1);
        var collisionB = detectCollision(stageWidth, -1, stageHeight, -1);
        var collision = collisionA.dt < collisionB.dt ? collisionA : collisionB;
        if (t + collision.dt > animationDuration) {
            var dt = animationDuration - t;
            t = animationDuration;
            x += dx * dt;
            y += dy * dt;
        } else {
            t += collision.dt;
            x = collision.x;
            y = collision.y;
            dx = collision.dx;
            dy = collision.dy;
        }
        allParticleKeyframes[index].push(generateKeyframe(t, x, y));
    }

    return keyframes;
}

function generateKeyframe(t, x, y) {
    return {left: x + "px", top: y + "px", offset: t / animationDuration };
}

function Particle(index)
{
    // Create visual element for the particle.
    var domNode = document.createElement('span');
    document.body.appendChild(domNode);

    // Set colour of element.
    domNode.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];

    function start() {
        var player = domNode.animate(allParticleKeyframes[index], {easing: "linear", iterations: Infinity, direction: "alternate", duration: animationDuration});
    }

    function destroy()
    {
        document.body.removeChild(domNode);
    }

    this.start = start;
    this.destroy = destroy;
}

function onCompletedRun() {
    testRunning = false;
    stopTrackingFrameRate();

    for (var i = 0; i < particles.length; i++)
        particles[i].destroy();
    particles = [];
}
</script>
</head>
</html>
